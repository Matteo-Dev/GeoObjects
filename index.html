<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoBuilder</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="assets/gb.ico" type="image/x-icon">
</head>
<body>
    <div class="container">
        <div class="page">
            <div class="section">
                <h2>Disclaimer</h2>
                <p>Ich besitze keinerlei Rechte an dem folgenden Gedankengut, da dies zu einem Großteil auf der Arbeit vom RP Freiburg und seiner Version dieses ABs basiert.</p>
            </div>
            <div class="section">
                <h2>Basics</h2>
                <p>In diesem Absatz gehe ich so verständlich wie möglich auf einige Basis-Konzepte von Java ein und versuche sie anhand von einfachen Beispiel zu erläutern.</p>
            </div>
            <div class="section">
                <h2>Basics - Das Konzept von objektorientierter Programmierung</h2>
                <p>In objektorientierter Programmierung (Absofort mit OOP abgekürzt) dreht sich alles um <b>Objekte</b>.</p>
                <p>Die erste Frage, die sich einem dann hierbei stellt, ist womöglich: <i>Schön, was aber ist jetzt ein Objekt? Also was kann es und wie macht man eins?</i></p>
                <p>Diese Frage lässt sich am besten mit einem praktischen Beispiel erläutern. Gehen wir nun einmal davon aus, dass wir irgendwie in der Welt des Programmierens in Java ein Auto darstellen wollen.</p>
                <p>Nun, genau für solche Fälle sind Objekte gedacht. Wir betrachten ein Auto nun also nicht einfach nur als Ding, sondern als Objekt. Ein Auto hat bestimmte Eigenschaften und kann bestimmte Dinge tun. Genau so soll also auch ein Objekt funktionieren.</p>
                <p>Die Eigenschaften eines Objektes nennt man hierbei <b>Attribute</b>, während die Fähigkeiten eines Objektes, also die Dinge, die es "tun kann", <b>Methoden</b> genannt werden.</p>
                <p>Wie erstellen wir nun aber ein Auto?</p>
                <p>Genau hier kommen dann <b>Klassen</b> ins Spiel. Eine Klasse kann als Blueprint, als Bauplan für ein Objekt angesehen werden, der genau festlegt, wie ein Objekt einmal auszusehen hat, d.h. was es alles für Eigenschaften und Fähigkeiten haben soll.</p>
                <p>In einer Klasse definieren wir Attribute und Methoden, über die dann ein Objekt dieser Klasse (Auch genannt <b>Instanz</b>) verfügen soll.</p>
                <p>Um das alles einmal praktisch zu veranschaulichen, versuchen wir nun einfach einmal ein sehr einfaches Auto Objekt in Java zu erstellen.</p>
                <p>Hierfür müssen wir uns zu allererst einmal überlegen, welche Eigenschaften und Fähigkeiten ein Auto überhaupt besitzen soll.</p>
                <p>Nun, für unser vereinfachtes Beispiel hat ein Auto auf jeden Fall eine Farbe, einen Modelname und kann hupen und fahren.</p>
                <p>Damit hätten wir zwei Attribute und zwei Fähigkeiten, die ein Auto Objekt also besitzen muss.</p>
                <p>Um nun ein Auto Objekt erstellen zu können, müssen wir erstmal den Bauplan für das Auto, also die Klasse für das Auto entwerfen.</p>
                <p>Diese nennen wir passend <code>Auto</code>.</p>
                <p>Sie soll zwei Attribute, eine Farbe <code>color</code> und einen Modelname <code>modelName</code> und zwei Methoden <code>hupen()</code> und <code>fahren()</code> haben.</p>
            </div>
            <div class="section">
                <h2>Basics - Encapsulation</h2>
                <p>Wir bleiben weiter bei den Beispiel des Autos.</p>
                <p>Um uns nun weiter der Erstellung der <code>Auto</code>-Klasse anzunähern, wenden wir auch gleich ein sehr wichtiges Konzept der OOP an: Encapsulation (DE: Verkapselung).</p>
                <p>In dieser geht es darum die Eigenschaften verschiedener Klassen, also später Objekten, voneinander abzugrenzen. Dies können wir durch die Verwendung von Sichtbarkeits-Modifizierern erreichen. Durch diese legen wir nämlich fest, auf welche Eigenschaften welches Objekt zugreifen kann.</p>
                <p>In Java stehen uns die folgenden zur Verfügung: <code>public</code>, <code>private</code> und <code>protected</code>.</p>
                <p>Der Sichtbarkeits-Modifizierer <code>public</code> bedeutet, dass auf dieses Attribut oder diese Methode direkt von außen zugegriffen werden kann. Das heißt, dass auch von außerhalb des Objektes direkt Änderungen an einem Attribut (das also als <code>public</code> definiert wurde) eines anderen Objektes vorgenommen werden können.</p>
                <p>Das komplette Gegenteil von <code>public</code> ist, wie es der Name schon vermuten lässt, <code>private</code>. Auf ein Attribut, was als <code>private</code> definiert wurde, kann niemals direkt von außerhalb des Objektes darauf zugegriffen werden. Um jedoch immernoch Änderungen an diesem Attribut vornehmen zu können, werden sogenannte <b>Getter</b> und <b>Setter</b> Methoden verwendet.</p>
                <p>Das Praktische an diesen Bezeichnungen ist, dass sie bereits im Vorhinein quasi alles über ihre Funktion verraten.</p>
                <p>Über einen Getter können wir den Wert eines Attributes lesen, ohne dabei direkt von außen auf dieses Attribut zuzugreifen. Wie der Name vermuten lässt, "getten" wir etwas durch ihn - Er gibt etwas zurück, nämlich den Wert des privaten Attributes.</p>
                <p>Ein Setter erlaubt es uns, ihm einen Wert zu übergeben und dann den Wert des entsprechenden Attributes auf diesen übergebenen Wert zu setzen. </p>
                <p>Über diese beiden Umwege können wir also, obwohl wir ein Attribut als <code>private</code> definiert haben, dessen Wert noch ändern. Der wichtige Unterschied hierbei ist, dass wir es in diesem Fall allerdings nicht direkt tun.</p>
                <p>Das gleiche, was ich nun bereits für Attribute erläutert habe, gilt auch für Methoden (nahezu). Bei Methoden weisen wir nun jedoch keinen Wert mehr zu, sondern wollen etwas ausführen, etwas tun.</p>
                <p>Damit regeln die Sichtbarkeits-Modifizierer von Methoden "nur noch", ob auf die jeweiligen Methoden von außerhalb oder nur von innerhalb eines Objektes aus zugegriffen werden kann.</p>
                <p>Ist eine Methode als <code>public</code> definiert, kann auch von außerhalb des Objektes auf die Methode zugegriffen werden. Bei <code>private</code> ist das genaue Gegenteil der Fall.</p>
                <p>Was genau das alles nun im Klartext bedeutet, wird hoffentlich bei der weiteren Ausführung der Erstellung unserer <code>Auto</code> Klasse klar.</p>
                <p>Abschließend sei zu diesem Absatz noch gesagt, dass der Sichtbarkeits-Modifizierer <code>protected</code> eine besondere Funktion hat, auf die ich erst im weiteren Verlauf dieses ABs eingehen werde. Bisher nur soviel: Seine Funktion hat etwas mit einem weiteren extrem wichtigen Konzept der OOP zu tun, der Vererbung. Hierzu jedoch später mehr.</p>
            </div>
            <div class="section">
                <h2>Basics - Methoden</h2>
                <p>Zuvor bin ich bereits auf Methoden im Allgemeinen ein wenig über die Beschreibung der Getter und Setter eingegangen.</p>
                <p>Hierzu sind bestimmt einige Fragen entstanden, die ich nun versuchen werde in diesem Abschnitt zu erläutern.</p>
                <p>Was genau bedeutet es denn, wenn einer Methode ein oder mehrere Werte übergeben werden?</p>
                <p>Um sich das auf eine sehr simple Art zu veranschaulichen, betrachten wir im folgenden eine Methode als eine Art mathematische Funktion.</p>
                <p>In diesem Beispiel sollte dann auch gleich das Konzept einer Methodenrückgabe klarer werden.</p>
                <p>Wir versuchen nun einfach mal (unabhängig zu dem Auto Beispiel aus den zuvorigen Abschnitten!) eine Methode für das Summieren zweier Ganzzahlen zu schreiben.</p>
                <p>Dafür müssen wir, wie bei einer mathematischen Funktion, erst einmal einen oder mehrere Werte in sie "hineinstecken", um einen weiteren "heraus", also zurückzubekommen.</p>
                <p>In Java müssen wir beachten, dass Java es vorschreibt (abgesehen von lambda-Funktionen - doch diese lassen wir in diesem AB außer Acht, bei mehr Interesse gerne direkt bei mir nachfragen), dass jede Funktion in einer Klasse steht und damit im Endeffekt nur über ein Objekt dieser Klasse oder in einem Objekt dieser Klasse aufgerufen werden kann.</p>
                <p>Ferner startet jedes Java-Programm immer in der <code>main</code> Methode, die sich in jedem Java-Programm in der folgenden Form auffinden lässt: </p>
                <pre>
                    <code class="JAVA">
    public static void main(String[] args) {
        // Anweisungen
    }
                    </code>
                </pre>
                <p>Hier finden wir auch gleich einen nun bereits bekannten Sichtbarkeits-Modifizierer, <code>public</code>, der von einem weiteren bisher unbekanntnen Schlüsselwort <code>static</code> und schließlich <code>void</code> gefolgt wird, bis wir schließlich beim Methodennamen <code>main</code> angekommen sind.</p>
                <p>In den Klammern folgt dann ein sogenannter Parameter, <code>args</code> vom Typ <code>String[]</code> (Was genau das nun bedeutet, ist zum jetzigen Stand erst einmal unwichtig). Auf dieses Konzept gehe ich nun im Bezug auf unsere Summen-Methode ein.</p>
                <p>Parameter erlauben es uns, einer Methode Werte von außen zu übergeben, mit denen wir dann etwas in der Methode anstellen können.</p>
                <p>So müssen wir, um das Ergebnis einer Addition von zwei Ganzzahlen zu erhalten, unserer Methode zwei Parameter übergeben: Den ersten und den zweiten Summanden.</p>
                <p>Da wir nur mit ganzen Zahlen rechnen, sollen beide Parameter von Typ <code>int</code> sein und die Namen <code>sum1</code> und <code>sum2</code> haben.</p>
                <p>Diese zwei übergebenen Werte rechnen wir in unserer Methode zusammen und geben das Ergebnis wieder zurück.</p>
                <p>So könnte eine relativ lange Version für unsere Additions-Methode wie folgt aussehen:</p>
                <pre>
                    <code class="JAVA">
    public int sum(int sum1, int sum2){
        int result = sum1 + sum2;
        return result;
    }
                    </code>
                </pre>
                <p>Wenn wir nun diese Methode einmal mit der <code>main</code> Methode vergleichen, fällt direkt etwas auf: Wo ist das <code>void</code> der <code>main</code> Methode hin?</p>
                <p>Nun, über dieses <code>void</code> sagen wir dem Java-Compiler, dass eine Methode <i>keinen</i> Wert zurückgibt, also genau das, was wir nicht wollen.</p>
                <p>Gerade unsere Additions-Methode soll ja aber das Ergebnis dieser Addition zurückgeben.</p>
                <p>Also müssen wir den Rückgabetypen dieser Methode ändern. Geben wir etwas in einer Methode zurück, müssen wir festlegen, von welchem Typ der zurückgegebene Wert sein wird.</p>
                <p>In unserem Fall wissen wir ja, dass wir nur mit Ganzzahlen, also keinen Kommazahlen rechnen und können demnach den Datentyp <code>int</code> als Rückgabetyp festlegen.</p>
                <p>Und wie geben wir nun einen Wert zurück?</p>
                <p>Dies erledigen wir über die <code>return</code> Anweisung. Der Wert, der ihr folgt, wird zurückgegeben.</p>
                <p>In unserer Additions-Methode geben wir den Wert von der Variablen <code>result</code> des Typs <code>int</code> zurück. In dieser Variablen ist das eigentliche Ergebnis der Addition der beiden Summanden gespeichert.</p>
                <p>Um die Methode ein wenig kürzer zu halten, wäre folgendes auch vollkommen legitim:</p>
                <pre>
                    <code class="JAVA">
    public int sum(int sum1, int sum2){
        return sum1 + sum2;
    }
                    </code>
                </pre>
                <p>Dann testen wir doch einfach mal unsere Methode!</p>
                <p>Da in Java alles in Klassen stehen muss, müssen wir also erst eine neue Datei erstellen und in dieser eine Klasse definieren, die allerdings keinerlei Eigenschaften besitzen muss. In ihr muss sich nur die <code>main</code> Methode befinden. Denn in dieser startet ja die Ausführung unseres Java-Programms.</p>
                <p>Weiter ist es in Java notwendig die eigentliche Datei so zu nennen, wie die in ihr definierte Klasse heißt.</p>
                <p>Wir nennen unsere "Anfangsklasse" einfach <code>Main</code> und fügen in diese das Code-Snippet der <code>main</code> Methode von weiter oben ein.</p>
                <p>Um im Java-Editor eine leere Java-Datei zu erstellen, klicke auf <code>Datei > Neu > Java</code> oder drücke <code>Strg + N</code></p>
                <p>Um diese Datei dann zu speichern und ihr einen Namen zu geben, klicke auf <code>Datei > Speichern</code> oder drücke <code>Strg + S</code>.</p>
                <p>In dem neu geöffneten Fenster kannst du nun den Speicherort und den Dateinamen festlegen.</p>
                <p>Abschließend einfach auf <code>Speichern</code> klicken.</p>
                <p>Damit sollte in der Datei <code>Main.java</code> nun folgendes stehen:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }
    }
                    </code>
                </pre>
                <p>Um nun unsere eigene Methode auszuprobieren, müssen wir diese einfach in die <code>Main</code> Klasse einfügen und (!) das Schlüsselwort <code>static</code> hinzufügen.</p>
                <p>Warum genau dies nun nötig ist würde nun etwas den Rahmen sprengen, deshalb sei lediglich gesagt, dass es notwendig ist und sonst einen Fehler geben würde, weil wir unsere Methode später aus der <code>main</code> Methode und damit aus einem statischen Kontext ausrufen werden, wodurch die aufgerufene Methode automatisch auch als <code>static</code> definiert sein muss.</p>
                <p>Damit sieht die fertige <code>Main</code> Klasse nun so aus:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }

        public static int sum(int sum1, int sum2){
            return sum1 + sum2;
        }
    }
                    </code>
                </pre>
                <p>Jedoch können wir bisher immer noch nicht sehen, was unsere eigene <code>sum()</code> Methode denn zurückgibt.</p>
                <p>Dafür müssen wir sie ja erstmal irgendwo aufrufen und ihr dabei zwei Werte von Typ <code>int</code> übergeben, denn so haben wir es ja in unserer Methoden-Definition festgelegt.</p>
                <p>Hierfür deklarieren wir in der <code>main()</code> Methode eine Variable <code>addition</code> vom Typ <code>int</code>.</p>
                <p>Anschließend weisen wir ihr einen Wert zu. Jedoch nicht wie bisher direkt eine Zahl, sondern den Wert, den <code>sum()</code> zurückgibt, wenn wir ihr zwei Ganzzahlen übergeben.</p>
                <p>Über den Befehl <code>System.out.println()</code> (Was im übrigen auch einfach nur ein Methoden-Aufruf ist), können wir uns Werte auf der Konsole ausgeben lassen. Nämlich genau den Wert, den wir ihr als Parameter (oder auch Argument genannt) übergeben.</p>
                <p>Damit sieht unser fertiges Additions-Programm wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            int addition;
            addition = sum(2, 3);
            System.out.println(addition);
        }

        public static int sum(int sum1, int sum2){
            return sum1 + sum2;
        }
    }

    // Nach Complilieren und Ausführen wird auf der Konsole ausgegeben:
    // 5
                    </code>
                </pre>
                <p>Versuche doch einfach mal eine Methode <code>mul()</code> für die Multiplikation zweier Ganzzahlen zu schreiben. Oder wie sieht es denn aus, wenn wir drei statt nur zwei Zahlen addieren wollen?</p>
                <p>Probiere einfach ein bisschen herum, das fördert nur dein Verständnis!</p>
            </div>

            <div class="section">
                <h2>Basics - Zurück zur Konstruktion des Autos</h2>
                <p>Nun mit unserem neuen Wissen wollen wir das Beispiel von einem Auto Objekt einmal zuende führen.</p>
                <p>Um einmal zu rekapitulieren:</p>
                <ul>
                    <li>Unser Auto Objekt soll folgende Attribute und Methoden besitzen: <code>color</code>, <code>model</code>, <code>fahren()</code> und <code>hupen()</code></li>
                    <li>Nach dem Konzept der Encapsulation müssen wir uns nun überlegen, welche Attribute und Methoden nach außen sichtbar sein sollen und welche nicht. In anderen Worten: Auf welche Eigenschaften von außen zugegriffen werden kann.</li>
                    <li>Zusätzlich müssen wir auch erst einmal überlegen, was genau wir in den Attributen speichern wollen. Daraus legen wir dann die entsprechenden Datentypen fest.</li>
                </ul>
                <p>Was muss denn nun alles von außen direkt aufrufbar sein?</p>
                <p>Nun, <code>color</code>, <code>model</code> müssen ja eigentlich nicht wirklich direkt von außen abrufbar sein. Eventuell wollen wir sie im Laufe des Programmes einmal auslesen oder sogar ändern, ein Auto kann ja auch neu lackiert werden und das können wir dann ja über den indirekten Zugriff über die Getter und Setter regeln.</p>
                <p>Das heißt, dass wir <code>color</code> und <code>model</code> auf jeden Fall als <code>private</code> definieren werden.</p>
                <p>Bleibt noch die Frage des Datentyps.</p>
                <p>Der einfachere Fall zuerst: In <code>model</code> wollen wir ja einen Modelnamen speichern. Und aus was besteht ein Name? Genau, aus vielen aneinandergehängten Zeichen. Damit fällt unsere Wahl des Datentyps von <code>model</code> eindeutig auf <code>String</code>, da sich in einem <code>String</code> Zeichenketten speichern lassen.</p>
                <p>In <code>color</code> soll ja eine Farbe gespeichert werden. Dies könnten wir zwar ganz einfach durch eine Zeichenkette, also einen <code>String</code> realisieren, indem wir z.B. einfach den hex-code einer Farbe als <code>String</code> in <code>color</code> speichern, jedoch ist das relativ unpraktisch.</p>
                <p>Da kommt es uns nur gelegen, dass Java bereits eine eigene Klasse <code>Color</code> definiert hat, die es uns erlaubt simpel <code>Color</code> Objekte zu erstellen, in denen wir dann die Werte für R (Rot), G (Grün) und B (Blau) speichern können und uns zusätzlich noch einige andere sehr praktische Methoden zur Verfügung stehen.</p>
                <p>Wichtig hierbei ist noch, dass wir, um diese Klasse in unserem Quellcode verwenden zu können, sie erst über den folgenden Befehl, den wir später ganz oben in die erste Zeile unseres Programms schreiben, importieren müssen.</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color;
                    </code>
                </pre>
                <p>Um ein Objekt <code>color</code> des Typs <code>Color</code> zu erstellen, verwenden wir folgendes Code-Snippet:</p>
                <pre>
                    <code class="JAVA">
    Color color = new Color(255, 0, 0);
                    </code>
                </pre>
                <p>Bevor ich nun genauer auf die Erklärung dieses Snippets eingehe, erst noch ein paar Worte zu der Formulierung "<i>Ein Objekt ... des Typs ...</i>":</p>
                <p>Mit dieser Formulierung lässt sich ausdrücken mithilfe welcher Klasse ein Objekt erstellt wird.</p>
                <p>So bedeutet in unserem Fall "<i>ein Objekt <code>color</code> des Typs <code>Color</code></i>", dass das Objekt <code>color</code> durch die Klasse <code>Color</code> festgelegt und sie damit also der Bauplan für das Objekt ist.</p>
                <p>In ihr steht also genau definiert, welche Eigenschaften und Fähigkeiten, also Attribute und Methoden ein Farb-Objekt haben sollte.</p>
                <p>Jetzt aber mal zur richtigen Erklärung des Snippets:</p>
                <p>Bisher sind wir nur darauf eingegangen, was eine Klasse eigentlich ist und wofür wir sie benötigen. Die Frage, wie wir denn nun ein Objekt nach dem Bauplan, den die Klasse vorgibt, erstellen ist allerdings immer noch offen.</p>
                <p>Das magische Wort lautet hier <b>Konstruktor</b>.</p>
                <p>Was ist nun aber ein Konstruktor?</p>
                <p>Jede Klasse muss über eine Methode verfügen, die bei der Erzeugung eines Objekts der Klasse aufgerufen wird. In dieser Methode können dann Werte initialisiert und erste Anweisungen durchgeführt werden. Diese Methode heißt Konstruktor.</p>
                <p>Er wird bei der Erstellung, also bei der Konstruktion eines Objekts aufgerufen.</p>
                <p>Für ihn gibt es ein paar Sonderregeln, die immer gelten:</p>
                <p>Die wichtigste davon ist dabei mit Sicherheit die folgende: Der Konstruktor muss immer in jeder Klasse ohne Ausnahme wie die Klasse benannt sein.</p>
                <p>Gleichzeitig muss er immer als <code>public</code> definiert werden, da er ja von außerhalb eines Objektes aufgerufen wird.</p>
                <p>Eine weitere Besonderheit ist, dass ein Konstruktor niemals einen Rückgabetyp hat, in seiner Definition also nie ein <code>void</code> oder ein Datentyp stehen darf.</p>
                <p>Im Großen und Ganzen ist der Konstruktor aber eben auch nur eine Methode.</p>
                <p>Das heißt für ihn gelten mit den paar zuvor genannten Einschränkungen, exakt dieselben Regel wir für jede andere beliebige Methode.</p>
                <p>Also können wir auch einem Konstruktor bestimmte Parameter übergeben, mit denen wir dann etwas in ihm anstellen können.</p>
                <p>So wollen wir ja schon bei der Erstellung eines Auto-Objektes unsere eigenen Farbe und den Modelnamen individuell festlegen lassen.</p>
                <p>Mit diesem ganzen neuen Wissen ist es uns nun sogar schon möglich eine erste Version (bisher ohne weitere Methoden, als den Konstruktor) der Klasse <code>Auto</code> zu entwerfen.</p>
                <p>Um es einmal davor noch kurz und knapp zusammenzufassen:</p>
                <ul>
                    <li>Die Klasse soll die zwei Attribute <code>color</code> und <code>model</code> besitzen, die beide als <code>private</code> definiert werden. Dabei hat <code>color</code> den Datentyp <code>Color</code> und <code>model</code> den bereits bekannten Datentyp <code>String</code>.</li>
                    <li>Außerdem benötigt sie einen Konstruktor, der den gleichen Namen wie sie selbst hat - Also <code>Auto()</code> - und als <code>public</code> definiert ist. <br> Außerdem soll er die beiden Parameter <code>color</code> vom Typ <code>Color</code> und <code>model</code> vom Typ <code>String</code> entgegennehmen.</li>
                </ul>
                <p>Damit sieht unser erster Entwurf der <code>Auto</code> Klasse wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return this.color;
        }
        public void setColor(Color newColor){
            this.color = newColor;
        }

        public String getModel(){
            return this.model;
        }
        public void setModel(String newModel){
            this.model = newModel;
        }
    }
                    </code>
                </pre>
                <p>Hierbei sei noch zu beachten, dass die Attribute bei ihrer Deklaration nicht direkt mit einem Wert initialisiert werden, sondern dies in dem Konstruktor geschehen soll.</p>
                <p>Eine Außnahme hierfür stellen konstante Attribute dar, da diese immer direkt in ihrer Deklaration initialisiert werden müssen. Anschließend kann ihr Wert jedoch auch an keinem Punkt in unserem Programm abgeändert werden.</p>
                <p>Würden wir zum Beispiel davon ausgehen, dass die Räderanzahl eines Autos immer nur gleich 4 sein sollte, so könnten wir das folgende Attribut einfügen (Das kannst du auch gerne tun 😄. Für den weiteren Verlauf dieses Turtorials ist dies allerdings irrelevalt):</p>
                <pre>
                    <code class="JAVA">
    private final int tires = 4;
                    </code>
                </pre>
                <p>Zuletzt noch ein paar Worte zu den Gettern und Settern der beiden privaten Attribute:</p>
                <p>In diesen Methoden ist dir wahrscheinlich schon das Schlüsselwort <code>this</code> aufgefallen. In diesen Fällen ist es zwar nicht notwendig, später werden wir allerdings noch sehen, warum wir es verwenden sollten.</p>
                <p>Unter <code>this</code> kannst du eine Art Referenz auf das eigene Objekt verstehen. Ein Ausdruck wie <code>this.color</code> bezieht sich also immer direkt auf das Objekt, bzw. genau das Attribut dieses Objektes, aus dem es aufgerufen wird.</p>
                <p>Die folgende Version des Quellcodes wäre damit auch vollkommen korrekt, wenn auch nicht gleich leicht verständlich:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Basics - Der Bauplan formt sich immer mehr und mehr</h2>
                <p>Unser erster Entwurf steht jetzt. Wir können die Dateien zwar schon komplilieren, jedoch fehlt noch eine kleine Sache.</p>
                <p>Setzen wir denn schon irgendwo die Werte der beiden Attribute?</p>
                <p>Um herauszufinden, was hier fehlt, erstelle, wenn du es bisher nicht sowieso von alleine weise vorausschauend gemacht hast, einen neuen Ordner und erstelle in diesem eine neue Datei für die Main-Klasse und eine weitere für die Auto-Klasse</p>
                <p>Ausgehend davon, dass der Ordner <i>AutoProject</i> heißt, sieht die Ordnerstruktur also wie folgt aus:</p>
                <pre>
                    <code class="DIR">
    AutoProjekt
        > Main.java
        > Auto.java
                    </code>
                </pre>
                <p>Den Basis-Code für eine die "Start"-Klasse, in der sich die <code>main()</code> Methode befindet, können wir hierbei einfach aus den Beispielen von zuvor kopieren und in <code>Main.java</code> einfügen.</p>
                <p>Damit steht in <code>Main.java</code>:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }
    }
                    </code>
                </pre>
                <p>In die <code>Auto</code> Klasse fügst du einfach den Entwurf aus dem letzten Abschnitt ein:</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color;

    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
                <p>Hierbei darfst du jedoch nicht den Import der <code>Color</code> Klasse vergessen, sonst meckert der Compiler bereits beim Kompilieren.</p>
            </div>

            <div class="section">
                <h2>Basics - Initialisierung im Konstruktor</h2>
                <p>Wie ich im letzen Abschnitt bereits ein wenig vorweg genommen habe, weisen wir unseren beiden Attributen bisher noch nirgendwo Werte zu.</p>
                <p>Das heißt sie zeigen bisher noch auf gar keine Referenz oder einen Wert, sondern lediglich <code>null</code>.</p>
                <p>Aus dem Abschnitt Konstruktoren im Allgemeinen ist dir eventuell noch im Kopf geblieben, für was sie denn normalerweise verwendet werden. Nämlich für die Initialisierung von Attributen.</p>
                <p>In unserem Fall wollen wir dafür ja dem Konstruktor zwei Werte übergeben, die er dann den beiden Attributen zuweist.</p>
                <p>Also schreiben wir doch einfach mal den Code hierfür. Das sollte leicht getan sein, sollte der Konstruktor also so aussehen:</p>
                <pre>
                    <code class="JAVA">
    public Auto(Color color, String model){ 
        color = color;
        model = model;
    }
                    </code>
                </pre>
                <p>Nun ja... </p>
                <p>Das ist doch schon etwas sehr verwirrend.</p>
                <p>Der Java-Compiler versteht zwar genau, was wir eigentlich meinen, wir selbst sind allerdings etwas verwirrt.</p>
                <p>Um diese Verwirrung zu beseitigen, verwenden wir für solche Fälle einfach das <code>this</code> Schlüsselwort, um eindeutig zu zeigen, welche Variable woherkommt.</p>
                <pre>
                    <code class="JAVA">
    public Auto(Color color, String model){ 
        this.color = color;
        this.model = model;
    }
                    </code>
                </pre>
                <p>So ist nun klar ersichtlich, dass der Teil des Ausdrucks links neben dem Gleichheitszeichen sich eindeutig auf das Attribut der Klasse bezieht und der rechte Teil die beiden Parameter meint.</p>
            </div>

            <div class="section">
                <h2>Basics - Unser Auto soll fahren!</h2>
                <p>Da unser Auto bisher noch nicht wirklich etwas kann und das ja doch echt ein bisschen langweilig wäre, fügen wir nun noch unsere zwei anfangs geplanten Methoden <code>fahren()</code> und <code>hupen()</code> ein.</p>
                <p>Um mit diesen allerdings nicht den Rahmen zu sprengen, halten wir sie sehr simpel und geben in ihnen nur einen Hinweis in der Konsole aus, dass sie aufgerufen wurden.</p>
                <p>Beide Methoden sollen dabei von außen aufgerufen werden können und nichts zurückgeben.</p>
                <p>Damit lautet die Methoden-Definition wie folgt:</p>
                <pre>
                    <code class="JAVA">
    public void fahren(){ 
        System.out.println("Das Model " + this.model + " fährt");
    }

    public void hupen(){
        System.out.println("Das Model " + this.model + " hupt");
    }
                    </code>
                </pre>
                <p>Hier verwenden wir, damit das Beispiel doch ein wenig interessanter wird, ein sehr praktisches Feature von Strings:</p>
                <p>Diese lassen sich nämlich unter Verwendung des Pluszeichens (+) sehr einfach zusammenfügen.</p>
                <p>In <code>model</code> ist ja der Modelname des Auto-Objekts als <code>String</code> gespeichert. Damit können wir ihn auch ganz einfach in einen Satz mit einfügen und uns diesen zusammengefügten Satz anschließend in der Konsole anschauen.</p>
                <p>So sieht unsere fertige <code>Auto</code> Klasse nun vervollständigt wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ 
            this.color = color;
            this.model = model;
        }

        public void fahren(){ 
            System.out.println("Das Model " + this.model + " fährt");
        }
    
        public void hupen(){
            System.out.println("Das Model " + this.model + " hupt");
        }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Basics - Das Auto fährt!</h2>
                <p>Mit unserer fertigen <code>Auto</code> Klasse können wir nun also unser erstes richtiges Auto Objekt erstellen.</p>
                <p>Dafür gehen wir nun in die <code>main()</code> Methode der <code>Main</code> Klasse und erstellen in dieser unser Objekt.</p>
                <p>Wie bereits in dem Abschnitt über den Konstruktor im Allgemeinen gezeigt, rufen wir bei der Erstellung eines Objektes einer Klasse den Konstruktor über das Schlüsselwort <code>new</code> gefolgt von seinem Namen auf.</p>
                <p>Allerdings benötigen wir ja zunächst erst noch zwei Werte, die wir ihm übergeben können - Die Farbe und den Modelnamen.</p>
                <p>Hierfür müssen wir nun zuerst in die erste Zeile in der <code>Main.java</code> Datei ebenfalls die Klasse <code>Color</code> importieren, da wir ja dem Konstruktor ein Objekt des Typs <code>Color</code> übergeben müssen.</p>
                <p>Dann initialisieren wir einfach zwei Variablen in der <code>main()</code> Methode, <code>farbe</code> vom Typ <code>Color</code> und <code>modelName</code> vom Typ <code>String</code>.</p>
                <p>Diesen können wir dann jeweils einen beliebigen Wert zuweisen. Für <code>modelName</code> suchen wir uns einfach einen Auto-Modelnamen, während <code>farbe</code> ja ein Objekt ist, weshalb wir hier den Konstruktor von <code>Color</code> aufrufen und ihm drei Werte für R, G und B übergeben müssen.</p>
                <p>Diese beiden Variablen übergeben wir dann einfach dem <code>Auto</code> Konstruktor.</p>
                <p>Um anschließend zu überprüfen, ob unser Auto-Objekt auch das tut, was es soll, können wir nun noch über das erstellte Objekt <code>auto1</code> die beiden Methoden <code>fahren()</code> und <code>hupen()</code> aufrufen.</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color; 

    public class Main {
        public static void main(String[] args) {
            Color farbe = new Color(0, 0, 0); // schwarz
            String modelName = "AMG";
            
            Auto auto1 = new Auto(farbe, modelName);
            auto1.fahren();
            auto1.hupen();
        }
    }
                    </code>
                </pre>
                <p>Durch dieses Snippet sollte auch gleich klar werden, wie man Methoden, die als <code>public</code> definiert sind über ein Objekt aufrufen kann.</p>
                <p>Probiere doch einfach mal dir nur den Modelnamen des Autos auf der Konsole ausgeben zu lassen oder ein zweies Auto-Objekt <code>auto2</code> zu erstellen, welches dann allerdings eine andere Frabe und einen anderen Modelnamen haben soll. Rufe dann auch hier die beiden Methoden auf und schau, was auf der Konsole ausgegeben wird.</p>
                <p>Abschließend sei noch gesagt, dass es auch kürzer als in dem Beispiel oben geht, da wir die beiden Variablen <code>farbe</code> und <code>modelName</code> eigentlich nicht benötigen, sondern deren Werte direkt dem Konstruktor übergeben können.</p>
                <p>Damit lässt sich das Programm ein wenig abkürzen:</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color; 

    public class Main {
        public static void main(String[] args) {
            Auto auto1 = new Auto(new Color(0, 0, 0), "AMG");
            auto1.fahren();
            auto1.hupen();
        }
    }
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Stufe 1</h2>
                <p>Wir beginnen mit dem Erstellen des einfachsten geometrischen Objektes: Dem Punkt. Dabei soll ein jeder Punkt die folgenden Eigenschaften haben:</p>
                <p>Eine <code>x</code> und <code>y</code> Koordinate und eine Darstellungscolor <code>color</code>.</p>
            </div>

            <div class="section">
                <h2>Testen_GPoint.java</h2>
                <p>Eine neue Datei <code>Testen_GPoint.java</code> erstellen, dann den folgenden Quellcode einfach kopieren und einfügen und abschließend <code>Testen_GPoint.java</code> compilieren und ausführen.</p>
                <p>Wird in der Konsole <code>Test was successful! Good job!</code> ausgegeben, dann funktioniert deine Methode perfekt. Siehst du stattdessen eine rote Fehlermeldung, dann stimmt leider etwas noch nicht ganz mit deiner Methode.</p>
                <pre>
                    <code>
    public class Testen_GPoint {
        private GPoint p;
        public int x, y;
    
        public Testen_GPoint(){
            this.x = 2;
            this.y = 2;
            p = new GPoint(x, y);
        }
    
        public void test() throws Exception {
            if(!(p.abstandZu(4, 4) == this.distanceTo(4, 4))) throw new Exception();
            else System.out.println("Test was successful! Good job!");
        }
    
        public double distanceTo(int mx, int my){
            double dx, dy, d;
            dx = (double) mx - this.x;
            dy = (double) my - this.y;
            d = Math.sqrt(dx * dx + dy * dy);
            return d;
        }
    
        public static void main(String[] args) throws Exception {
            Testen_GPoint pointTest = new Testen_GPoint();
            pointTest.test();
        }
    }
                    </code>
                </pre>
            </div>
            <div class="section">
                <h2>Stufe 5: Neue Punkte erstellen</h2>
                <p>
                    Die Punkte sollen nun ja, nicht wie zum Ende der vorherigen Stufe beschrieben im Konstruktor der Board-Klasse, vom  Benutzer erzeugt werden. So soll bei einem Mausklick ein neues <code>GPoint</code> Objekt (mit den Koordinaten der Stelle des Klicks auf der Zeichenfläche) erstellt und in die Liste <code>geoObjects</code> eingefügt werden.                    
                </p>
                <p>
                    Um dieses Mausklick-Event "abzufangen", können wir die Methode <code>Board.mousePressed(MouseEvent e)</code> benutzen. Diese wird von JAVA nämlich genau dann aufgerufen, wenn die primäre (also die linke) Maustaste gedrückt wurde.
                </p>
                <p>
                    Also schreiben wir in diese <code>mousePressed()</code> Methode unseren Quellcode, der einen neuen Punkt erzeugt und der <code>geoObjects</code> Liste hinzufügt (Nach demselben Prinzip, wie wir es bereits im Konstruktor von <code>Board</code> gemacht haben).
                </p>
                <p>
                    Zur Initialisierung eines neuen <code>GPoint</code> Objektes benötigen wir eine x und y Koordinate, die diesem dann "zugewiesen" (In anderen Worten: Dem Konstruktor übergeben) wird. Diese Koordinaten liefert uns der Parameter <code>MouseEvent e</code>. Ganz einfach formuliert übergibt das "System" (Was auch immer hier genau das System sein mag) der <code>mousePressed()</code> Methode ein Objekt vom Typ <code>MouseEvent</code>, in welchem z.B. die Koordinaten des Mauszeigers bei Auslösung des Events gespeichert sind. 
                </p>
                <p>
                    Um nun in der Methode mit diesen Koordinaten etwas anfangen zu können, die in dem <code>e</code> Objekt (Das ja eigentlich der übergebene Parameter der Methode ist) enthalten sind, benutzen wir folgendes Code-Snippet:
                </p>
                <pre>
                    <code class="JAVA">
    int mx = e.getX();
    int my = e.getY();
                    </code>
                </pre>
                <p>
                    So sind nach diesen beiden Zeilen die x und y Koordinate der Mausposition in <code>mx</code> und <code>my</code> gespeichert.
                </p>
                <div class="exercise">
                    <p>
                        Stelle eine Kopie deines Projekts in einem neuen Verzeichnis <code>GeomObj_D</code> her. Ergänze die <code>mousePressed()</code> Methode in der <code>Board</code> Klasse dann so, dass bei einem Mausklick an eine leere Stelle der Zeichnung ein neuer Punkt erzeugt wird.
                    </p>
                    <p>
                        Dieser Punkt muss dann natürlich auch noch in die <code>geoObjects</code> Liste hinzugefügt werden.
                    </p>
                    <p>
                        Zusätzlich sollte nach dem Einfügen eines neuen Punktes das <code>Board</code> neu geladen werden, damit der neue Punkt auch angezeigt wird. Dies lässt sich ganz einfach über einen Aufruf der Methode <code>repaint()</code> ganz am Ende deines Codes in der <code>mousePressed()</code> Methode erreichen. Wunder dich nicht, dass du nirgendwo direkt eine Definition dieser <code>repaint()</code> Methode siehst, <code>Board</code> erbt diese nämlich von <code>JPanel</code>.
                    </p>
                </div>
                <div class="exercise">
                    <p>
                        Verschiebe den Quellcode für das Einfügen von Punkten vorübergehend(!) von <code>mousePressed()</code> nach <code>mouseReleased()</code> bzw <code>mouseDragged()</code>. Was ändert sich dabei jeweils am Verhalten des Programms?
                    </p>
                    <p>
                        Wenn du etwas mehr wissen möchtest, dann kannst du über den Befehl <code>System.out.println(geoObjects.size());</code> im Konsolenfenster ausgeben lassen, wie groß die <code>geoObjects</code> Liste zum jeweiligen Zeitpunkt ist, d.h. wie viele Punkte schon hinzugefügt wurden.
                        <br>
                        Füge diesen dafür einfach in den Methoden <code>mousePressed()</code>, <code>mouseReleased()</code> bzw <code>mouseDragged()</code> ein.
                    </p>
                    <p>
                        Zu guter Letzt musst du nun den verschobenen Quellcode wieder zurück in die <code>mousePressed()</code> Methode verschieben (und ggf. den <code>System.out...</code> Befehl wieder entfernen)
                    </p>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 6: Jetzt wird's dynamisch!</h2>
                <p>
                    Nun können wir Punkte per Mausklick hinzufügen. Allerdings wollen wir nun diese plazierten Punkte auch verschieben können. 
                    Dies regeln wir wie folgt:
                </p>
                <p>
                    Wenn die Maustaste auf einen schon vorhandenen Punkt p (oder hinreichend dicht bei p) gedrückt wird, dann soll dieser Punkt als <code>dragPoint</code>, also als "zu verziehender" Punkt gespeichert werden.
                    Wird nun die Maus bei weiterhin gedrückter Taste bewegt, soll dieser Punkt der Mausbewegung folgen, bis die Maustaste wieder losgelassen wird.
                </p>
                <p>
                    Hierfür müssen wir natürlich erst einmal wissen, ob die Koordinaten des Mauszeigers beim Klicken in der Nähe, bzw. "ganz dicht" an einem bereits existierenden Punkt liegen. 
                </p>
                <p>
                    Dies erledigen wir in der Methode <code>mousePressed()</code> von <code>Board</code>, die ja immer dann aufgerufen wird, wenn die primäre Maustaste gedrückt wurde. 
                </p>
                <p>
                    Dann untersuchen wir als erstes einfach alle Punkte der <code>geoObjects</code> Liste darauf, wie dicht sie bei der aktuellen Mausposition liegen. Eine dafür benötigte Schleife findest du bereits in der <code>Board.paint()</code> Methode oder hier:
                </p>
                <pre>
                    <code class="JAVA">
    for (GPoint p: geoObjects) {
        // Anweisungen hier einfügen
    }                   
                    </code>
                </pre>
                <p>
                    In dieser Schleife ist eine Art "Laufvariable" definiert, <code>p</code> von Typ <code>GPoint</code>. Diese Schleife "läuft" über die Liste <code>geoObjects</code> und ihre Laufvariable <code>p</code> nimmt in jedem Durchlauf den Wert an der Stelle der Liste an, an der die Schleife momentan steht.
                    <br>
                    D.h. wenn wir annehmen, dass an der nullten Stelle von <code>geoObjects</code> das Objekt <code>GPoint point1 = new GPoint(1, 1)</code> steht, so würde die Laufvariable <code>p</code> im allerersten Schleifendurchlauf die Referenz des Objekts <code>point</code> annehmen.
                </p>
                <p>
                    Hier die ganze Erklärung in Code ausgeschrieben:
                </p>
                <pre>
                    <code class="JAVA">
    ArrayList&lt;GPoint&gt; geoObjects = new ArrayList&lt;GPoint&gt;();
    GPoint point1 = new GPoint(1, 1);
    geoObjects.add(point1);
    GPoint point2 = new GPoint(2, 2);
    geoObjects.add(point2);

    for (GPoint p: geoObjects) {
        System.out.println("X: " + p.getX() + "; Y: " + p.getY());
    }                   

    // Gibt in der Konsole aus: 
    // X: 1; Y: 1
    // X: 2; Y: 2
                    </code>
                </pre>
                <p>
                    Wie groß der Abstand zwischen zwei Punkten, also des Punktes <code>p</code> und der aktuellen Mausposition, ist, können wir über einen Aufruf der bereits in Schritt 3 geschriebenen Methode <code>abstandZu()</code> der Klasse <code>GPoint</code> berechnen.
                </p>
                <p>
                    Hierfür übergeben wir dieser Methode einfach die Maus-Koordinaten, welche uns wie bereits in Schritt 5 erwähnt, über den Parameter <code>e</code> des Typs <code>MouseEvent</code> übergeben werden: <code>e.getX()</code> und <code>e.getY()</code> geben die jeweilige Koordinate zurück.
                </p>
                <p>
                    Wir erinnern uns: Da die Methode <code>abstandZu()</code> zur Klasse <code>GPoint</code> gehört und wir sie als <code>public</code> definiert haben, können wir sie über jedes Objekt vom Typ <code>GPoint</code> aufrufen. So dann auch über die Laufvariable <code>p</code> der Schleife, da diese ja vom Typ <code>GPoint</code> ist und in jedem Durchlauf das Element in der <code>geoObjects</code> Liste an der momentanen Stelle in ihr gespeichert wird. Darüber lässt sich ganz einfach der Abstand zwischen einem jeden Punkt, der auch ein Element in <code>geoObjects</code> ist und dem Mauscursor berechnen, indem wir über das Objekt <code>p</code> (Die Laufvariable) <code>abstandZu()</code> aufrufen und dieser Methode die Koordinaten des Mauscursors, also <code>e.getX()</code> und <code>e.getY()</code> übergeben.
                </p>
                <p>
                    Dieser Methodenaufruf liefert der Methodendefinition nach einen Wert von Typ <code>double</code>, den Abstand zwischen den beiden Punkten, also genau das, was wir eigentlich brauchen.
                </p>
                <p>
                    Ist der Abstand nun kleiner als 4 (Pixel), so weisen wir der Variablen <code>dragPoint</code> den Punkt p zu; andernfalls behält <code>dragPoint</code> den Wert <code>null</code> (D.h. wir müssen ihn nicht erneut auf <code>null</code> setzen).
                </p>
                <p>
                    Anschließend überprüfen wir dann, ob <code>dragPoint</code> nicht <code>null</code> ist. Wenn dies der Fall ist, soll dieser Punkt so lange der Maus folgen, bis die Maustaste wieder losgelassen wird.
                </p>
                <p>
                    Dies erreichen wir, indem wir in der <code>mouseDragged()</code> Methode den gezogenen Punkt, also <code>draggedPoint</code> stets an die aktuelle Mausposition setzen.
                    <br>
                    Auch in dieser Methode erhalten wir die Koordinaten des Mauszeigers über den übergebenen Parameter <code>e</code> des Typs <code>MouseEvent</code>:
                </p>
                <pre>
                    <code class="JAVA">
    dragPoint.setX(e.getX());
    dragPoint.setY(e.getY());
                    </code>
                </pre>
                <p></p>
                <p>
                    Nun sind zwar die Koordinaten des gezogenen Punktes aktualisiert, jedoch wird diese Änderung noch nicht angezeigt.
                    <br>
                    Auch hier müssen wir die Methode <code>repaint()</code> zum Neuladen, also zum Aktualisieren des Fensters aufrufen.
                </p>
                <p>
                    Was aber, wenn <code>dragPoint</code> gleich <code>null</code> ist? Dann wurde die primäre Maustaste an einer freien Stelle des Zeichenbreichs gedrückt. In dieser Situation sollten wir also einen neuen Punkt hinzufügen - Also genau das tun, was wir bereits in Schritt 5 getan haben! 
                </p>
                <p>
                    Baue also den schon vorhandenen Quelltext zur Erzeugung eines neuen Punktes so in die neue <code>mousePressed()</code> Methode ein, dass er nur noch im Falle <code>dragPoint == null</code> ausgeführt wird.
                </p>
                <p>
                    Abschließend müssen wir noch den Zugvorgang beim Loslassen der Maustaste beenden. 
                    <br>
                    Hierfür muss einfach in <code>mouseReleased()</code> die Variable <code>dragPoint</code> auf null zu setzen.
                </p>
                <div class="exercise">
                    <p>
                        Erstelle eine Kopie deines Projektes in einem neuen Verzeichnis <code>GeomObj_E</code> und ergänze die Maus-Methoden in der Klasse <code>Board</code> wie oben beschrieben.
                    </p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mousePressed()</code> {
                    </p>
                    <p style="padding-left: 20px">if-Schleife ("<i>Ist <code>dragPoint</code> nicht gleich null?</i>") {</p>
                    <p style="padding-left: 40px">for-Schleife {</p>
                    <p style="padding-left: 60px">if-Schleife (" <i> Ist der Abstand zwischen Punkt <code>p</code>(der Laufvariablen der Schleife) und dem Punkt mit den Koordinaten (<code>e.getX()</code>|<code>e.getY()</code>) kleiner als 4?" </i>) { </p>
                    <p style="padding-left: 80px">Setze <code>dragPoint</code></p>
                    <p style="padding-left: 60px">}</p>
                    <p style="padding-left: 40px">}</p>
                    <p style="padding-left: 40px">repaint</p>
                    <p style="padding-left: 20px">}</p>
                    <p>}</p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mouseDragged()</code> {
                    </p>
                    <p style="text-indent: 20px">Setze neue Koordinaten für <code>dragPoint</code></p>
                    <p>}</p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mouseReleased()</code> {
                    </p>
                    <p style="text-indent: 20px">Reset <code>dragPoint</code> (auf <code>null</code>)</p>
                    <p>}</p>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 7: Andere geometrische Objekte: Strecken</h2>
                <p>
                    Nun wollen wir in unserer Applikation ja nicht nur mit Punkten arbeiten, sondern mit "komplexeren" geometrischen Objekten, wie z.B. Strecken.
                </p>
                <p>
                    Hierfür benötigen wir logischerweise auch gleich eine neue Klasse <code>GLine</code>. 
                </p>
                <p>
                    Genau wie die Punkte, sollen sich auch die Strecken mit Hilfe einer <code>draw()</code> Methode im Zeichenfenster darstellen können.
                </p>
                <p>
                    Strecken haben stets einen Anfangs- und einen Endpunkt und (genau wie die Punkte) eine Farbe, somit ist das folgende UML-Diagramm für die Strecken naheliegend:
                </p>
                <div class="center">
                    <img src="./assets/dia1.png" alt="" srcset="">
                </div>
                <p>
                    Nun stoßen wir allerdings schnell auf ein großes Problem: Wenn wir die Klasse <code>GLine</code> fertig implementiert und eine Instanz dieser Klasse, also ein Strecken-Objekt erzeugt hätten, müssten wir dieses ja auch in die <code>geoObjects</code> Liste eintragen.
                </p>
                <p>
                    Hier stellt sich jedoch JAVA quer - in die <code>geoObjects</code> Liste können ja nur Objekte vom Typ <code>GPoint</code> hinzugefügt werden. 
                    <br>
                    Gleichzeitig gibt es keine Möglichkeit, in einer solchen <code>ArrayList</code> mehrere Objekte von verschiedenen Typen, also mehrere Instanzen verschiedener Klassen zu speichern.
                </p>
                <p>
                    Somit brauchen wir eine Art gemeinsame "Oberklasse" für <code>GPoint</code> und <code>GLine</code>. Beide Klassen beschreiben ja GeoObjekte, also bietet sich für den Namen der übergeordneten Oberklasse <code>GeoObjects</code> prima an.
                </p>
                <p>
                    Diese Klasse soll nun alle Eigenschaften (also Attribute) und Methoden beinhalten, die im oberen UML Diagramm sowohl in <code>GPoint</code> und <code>GLine</code> vorhanden sind.
                </p>
                <p>
                    Alle anderen Eigenschaften, in denen sich die beiden Klassen unterscheiden, bleiben damit in ihnen selbst. Damit sind <code>GPoint</code> und <code>GLine</code> jeweils Spezialisierungen von <code>GeoObject</code>.
                </p>
                <p>

                </p>
            </div>
        </div>
    </div>
</body>
</html>